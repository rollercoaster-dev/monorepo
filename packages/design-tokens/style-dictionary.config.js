import StyleDictionary from "style-dictionary";

// Custom transform for CSS variable name - handles different token categories
StyleDictionary.registerTransform({
  name: "name/css/ob",
  type: "name",
  transform: (token) => {
    const path = token.path;

    // Foundational tokens keep their full path (color.primary -> --ob-color-primary)
    // Semantic and component tokens use their key directly (background -> --ob-background)
    const prefix = path[0];

    // These prefixes should be kept in the variable name
    const foundationalPrefixes = [
      "color",
      "font",
      "space",
      "radius",
      "shadow",
      "transition",
      "zIndex",
    ];

    if (foundationalPrefixes.includes(prefix)) {
      return `--ob-${path.join("-")}`;
    }

    // For semantic/component tokens, output the flat name
    return `--ob-${path.join("-")}`;
  },
});

// Custom transform to convert token references to CSS var() syntax
// This keeps references intact so theme switching works properly
StyleDictionary.registerTransform({
  name: "value/css/ob-references",
  type: "value",
  transitive: false, // Don't resolve transitively - keep var() references
  transform: (token) => {
    // Access the original value before Style Dictionary resolves it
    const originalValue = token.original?.$value ?? token.original?.value;
    if (
      typeof originalValue === "string" &&
      originalValue.startsWith("{") &&
      originalValue.endsWith("}")
    ) {
      // Convert {path.to.token} to var(--ob-path-to-token)
      const refPath = originalValue.slice(1, -1).replace(/\./g, "-");
      return `var(--ob-${refPath})`;
    }
    // Return the resolved value for non-reference tokens
    return token.$value ?? token.value;
  },
});

// Helper to convert token reference to CSS var()
function toVarRef(refString) {
  // Convert {path.to.token} to var(--ob-path-to-token)
  const refPath = refString.slice(1, -1).replace(/\./g, "-");
  return `var(--ob-${refPath})`;
}

// Helper to get the CSS value for a token (preserving references)
function getCSSValue(token) {
  const originalValue = token.original?.$value ?? token.original?.value;

  // If the original value is a reference, convert to var()
  if (
    typeof originalValue === "string" &&
    originalValue.startsWith("{") &&
    originalValue.endsWith("}")
  ) {
    return toVarRef(originalValue);
  }

  // Otherwise use the resolved value
  return token.$value ?? token.value;
}

// Custom format for CSS tokens that matches original tokens.css structure
StyleDictionary.registerFormat({
  name: "css/ob-variables",
  format: ({ dictionary }) => {
    const header = `/**
 * OpenBadges UI — Token Contract v1
 *
 * Auto-generated by Style Dictionary from design-tokens package.
 * DO NOT EDIT DIRECTLY.
 *
 * This file defines the public CSS custom property API for theming openbadges-ui.
 * It follows a three-tier architecture:
 *
 *   Foundational  →  primitive values (palette, font stacks, spacing scale)
 *   Semantic      →  context-based tokens (background, foreground, primary, muted…)
 *   Component     →  per-component overrides that default to semantic tokens
 */

`;

    let output = header + ":root {\n";

    // Group tokens
    const foundational = {
      color: [],
      font: [],
      space: [],
      radius: [],
      shadow: [],
      transition: [],
      zIndex: [],
    };
    const semantic = [];
    const component = [];

    // Sort tokens into categories
    dictionary.allTokens.forEach((token) => {
      const prefix = token.path[0];

      if (foundational[prefix]) {
        foundational[prefix].push(token);
      } else if (token.filePath?.includes("semantic")) {
        semantic.push(token);
      } else if (token.filePath?.includes("components")) {
        component.push(token);
      } else {
        semantic.push(token);
      }
    });

    // Output foundational tokens
    output +=
      "\n  /* ══════════════════════════════════════════════════════════════ */\n";
    output +=
      "  /* FOUNDATIONAL TOKENS (Primitives)                              */\n";
    output +=
      "  /* ══════════════════════════════════════════════════════════════ */\n";

    Object.entries(foundational).forEach(([category, tokens]) => {
      if (tokens.length > 0) {
        const label = category.charAt(0).toUpperCase() + category.slice(1);
        output += `\n  /* ── ${label} ── */\n`;
        tokens.forEach((token) => {
          output += `  ${token.name}: ${getCSSValue(token)};\n`;
        });
      }
    });

    // Output semantic tokens
    if (semantic.length > 0) {
      output +=
        "\n  /* ══════════════════════════════════════════════════════════════ */\n";
      output +=
        "  /* SEMANTIC TOKENS (Public Contract)                              */\n";
      output +=
        "  /* ══════════════════════════════════════════════════════════════ */\n\n";
      semantic.forEach((token) => {
        output += `  ${token.name}: ${getCSSValue(token)};\n`;
      });
    }

    // Output component tokens
    if (component.length > 0) {
      output +=
        "\n  /* ══════════════════════════════════════════════════════════════ */\n";
      output +=
        "  /* COMPONENT TOKENS                                               */\n";
      output +=
        "  /* ══════════════════════════════════════════════════════════════ */\n\n";
      component.forEach((token) => {
        output += `  ${token.name}: ${getCSSValue(token)};\n`;
      });
    }

    output += "}\n";
    return output;
  },
});

// Custom format for JS theme objects
StyleDictionary.registerFormat({
  name: "javascript/ob-tokens",
  format: ({ dictionary }) => {
    const tokens = {};

    dictionary.allTokens.forEach((token) => {
      let current = tokens;
      const path = token.path;

      for (let i = 0; i < path.length - 1; i++) {
        if (!current[path[i]]) {
          current[path[i]] = {};
        }
        current = current[path[i]];
      }
      current[path[path.length - 1]] = token.$value ?? token.value;
    });

    return `// Auto-generated by Style Dictionary
export const tokens = ${JSON.stringify(tokens, null, 2)};

export default tokens;
`;
  },
});

// Custom format for Tailwind config
StyleDictionary.registerFormat({
  name: "tailwind/ob-config",
  format: ({ dictionary }) => {
    const colors = {};
    const spacing = {};
    const borderRadius = {};
    const fontSize = {};
    const fontWeight = {};
    const lineHeight = {};
    const fontFamily = {};
    const boxShadow = {};
    const transitionDuration = {};
    const zIndex = {};

    dictionary.allTokens.forEach((token) => {
      const path = token.path;
      const value = token.$value ?? token.value;

      switch (path[0]) {
        case "color":
          if (path[1] === "gray") {
            if (!colors.gray) colors.gray = {};
            colors.gray[path[2]] = value;
          } else {
            const name = path.slice(1).join("-") || path[0];
            colors[name] = value;
          }
          break;
        case "space":
          spacing[path[1]] = value;
          break;
        case "radius":
          borderRadius[path[1]] = value;
          break;
        case "font":
          if (path[1] === "size") {
            fontSize[path[2]] = value;
          } else if (path[1] === "weight") {
            fontWeight[path[2]] = value;
          } else if (path[1] === "lineHeight") {
            lineHeight[path[2]] = value;
          } else if (path[1] === "family") {
            fontFamily[path[2]] = value;
          }
          break;
        case "shadow":
          boxShadow[path[1]] = value;
          break;
        case "transition":
          transitionDuration[path[1]] = value;
          break;
        case "zIndex":
          zIndex[path[1]] = value;
          break;
      }
    });

    const config = {
      theme: {
        extend: {
          colors,
          spacing,
          borderRadius,
          fontSize,
          fontWeight,
          lineHeight,
          fontFamily,
          boxShadow,
          transitionDuration,
          zIndex,
        },
      },
    };

    return `// Auto-generated by Style Dictionary
// Tailwind CSS configuration with OpenBadges design tokens

/** @type {import('tailwindcss').Config} */
export const obTokens = ${JSON.stringify(config, null, 2)};

export default obTokens;
`;
  },
});

// Custom format for Tamagui tokens
StyleDictionary.registerFormat({
  name: "tamagui/ob-tokens",
  format: ({ dictionary }) => {
    const tokens = {
      color: {},
      space: {},
      size: {},
      radius: {},
      zIndex: {},
    };

    dictionary.allTokens.forEach((token) => {
      const path = token.path;
      const value = token.$value ?? token.value;

      switch (path[0]) {
        case "color":
          if (path[1] === "gray") {
            tokens.color[`gray${path[2]}`] = value;
          } else {
            const name = path.slice(1).join("") || path[0];
            const camelName = name.replace(/-([a-z])/g, (g) =>
              g[1].toUpperCase(),
            );
            tokens.color[camelName] = value;
          }
          break;
        case "space":
          if (typeof value === "string" && value.endsWith("rem")) {
            tokens.space[`$${path[1]}`] = parseFloat(value) * 16;
          } else {
            tokens.space[`$${path[1]}`] = value;
          }
          break;
        case "radius":
          if (typeof value === "string" && value.endsWith("rem")) {
            tokens.radius[`$${path[1]}`] = parseFloat(value) * 16;
          } else if (typeof value === "string" && value.endsWith("px")) {
            tokens.radius[`$${path[1]}`] = parseInt(value);
          } else {
            tokens.radius[`$${path[1]}`] = value;
          }
          break;
        case "font":
          if (path[1] === "size") {
            if (typeof value === "string" && value.endsWith("rem")) {
              tokens.size[
                `$fontSize${path[2].charAt(0).toUpperCase() + path[2].slice(1)}`
              ] = parseFloat(value) * 16;
            }
          }
          break;
        case "zIndex":
          tokens.zIndex[`$${path[1]}`] = parseInt(value);
          break;
      }
    });

    return `// Auto-generated by Style Dictionary
// Tamagui tokens for OpenBadges React Native app

import { createTokens } from '@tamagui/core';

export const obColor = ${JSON.stringify(tokens.color, null, 2)};

export const obSpace = ${JSON.stringify(tokens.space, null, 2)};

export const obSize = ${JSON.stringify(tokens.size, null, 2)};

export const obRadius = ${JSON.stringify(tokens.radius, null, 2)};

export const obZIndex = ${JSON.stringify(tokens.zIndex, null, 2)};

export const tokens = createTokens({
  color: obColor,
  space: obSpace,
  size: obSize,
  radius: obRadius,
  zIndex: obZIndex
});

export default tokens;
`;
  },
});

// Build configuration
export default {
  source: ["src/tokens/**/*.json"],
  platforms: {
    css: {
      transforms: ["name/css/ob", "value/css/ob-references"],
      buildPath: "build/css/",
      files: [
        {
          destination: "tokens.css",
          format: "css/ob-variables",
        },
      ],
    },
    js: {
      transforms: [],
      buildPath: "build/js/",
      files: [
        {
          destination: "index.js",
          format: "javascript/ob-tokens",
        },
      ],
    },
    tailwind: {
      transforms: [],
      buildPath: "build/tailwind/",
      files: [
        {
          destination: "tailwind.config.js",
          format: "tailwind/ob-config",
        },
      ],
    },
    tamagui: {
      transforms: [],
      buildPath: "build/tamagui/",
      files: [
        {
          destination: "tokens.js",
          format: "tamagui/ob-tokens",
        },
      ],
    },
  },
};
